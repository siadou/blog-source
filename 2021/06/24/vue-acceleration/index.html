<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>vue项目性能优化笔记 · 绝好调超</title><meta name="description" content="项目背景最近在做一个基于vue的项目，用户可以通过在表格里设置各种控件，让使用者在不同的流程提交不同的字段。同事在使用时配置了一个900多个组件的table，用的时候感觉表很卡顿，每次输入字符都会卡顿好久才会有响应。于是我奉命对表单进行优化。
我首先研究了一下卡顿的原因：最开始在设计的时候把所有的w"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">绝好调超</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>vue项目性能优化笔记</a></h3></div><div class="post-content"><h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>最近在做一个基于vue的项目，用户可以通过在表格里设置各种控件，让使用者在不同的流程提交不同的字段。同事在使用时配置了一个900多个组件的table，用的时候感觉表很卡顿，每次输入字符都会卡顿好久才会有响应。于是我奉命对表单进行优化。</p>
<p>我首先研究了一下卡顿的原因：最开始在设计的时候把所有的widget放在了一个form里面，也把每个widget绑定的值绑在了form的data里。每个widget的值修改的时候，form的data发生改变，触发form重新渲染。由于这个表单太大，本身渲染就会花费很多时间（以下为省略结构，实际上还要复杂很多）而且实际在用的时候不仅form会重新渲染，子元素widget也会重新渲染，虽然不会触发卡顿问题，但是仍然对性能造成消耗。发现这个问题的时候我忽然想到，其实这种问题在以前的jquery时代是不存在的，每次修改表单的字符最多只是对当前widget的修改。怎么到了vue反而越来越糟糕，每次修改值都会触发整个表单和所有widget的重新渲染。于是我构思了优化的方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;widget v-model&#x3D;&quot;model.k1&quot; @change&#x3D;&quot;changeHandler(widget.id)&quot; :key&#x3D;&quot;widget.id&quot;&#x2F;&gt;</span><br><span class="line">    .....</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export defualt &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            model: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>相比于react，vue 是响应式框架，自带优化。组件的渲染方法和渲染需要的参数绑定。即使父组件更新了，子组件如果接受到的prop等参数没有更新的话也不会触发子组件的重绘。这点与react不同，react需要构造pureComponent或者手写shouldComponentUpdate才会对渲染进行优化。<br>除此以外，我们的项目由于需要支持IE11暂时还没升级到vue3.0。但是我们了解到vue3.0在一些渲染方面做了优化。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>于是我从以下几点对form进行了优化：</p>
<ol>
<li>widget的结构优化</li>
</ol>
<p>这是第一次优化，也是一次应急优化。之前widget不维护内部变量，每次input都会更新model。我把一部分的widget的内部变量维护逻辑放在了组件里，避免频繁地更新外部变量。</p>
<p>除此以外，升级了element-ui之后，组件input/change的触发逻辑有了区分。input widget的change只会在blur时触发。于是我把复杂的涉及逻辑表单的逻辑放在了change里，简单的修改值的操作放在了input里。避免了不必要的计算。</p>
<ol start="2">
<li>避免绑定事件造成的widget重新渲染</li>
</ol>
<p>理论上来讲，单个widget的值更新后，form重新渲染应该不会触发其他widget的重新渲染。可实际上所有的widget都会重新渲染一遍。</p>
<p>原因是vue之前的版本不会保存事件handler.bind后的结果，每一次组件都会绑定新的listener。导致每次form重新渲染都会生成新的handler,从而触发子组件的渲染。</p>
<p>针对这个问题，我对lister设置了缓存。每次重渲染都会针对不同的widget读取上一次的值，解决了这个问题。</p>
<p>vue3.0也针对这里做了优化。这样在使用template的时候就不需要手动去设置缓存了（但是我们这里用的是jsx其实即使升级也需要手动优化…）。</p>
<ol start="3">
<li>拆分变与不变</li>
</ol>
<p>我们的表单在设计的时候包含了逻辑表单的功能，在用户填写表单的时候能够通过单个选项的值控制部分widget的显示与隐藏。实际在用的时候，我发现即使优化了widget的渲染，在修改逻辑表单的值时一些情况下仍然会触发所有widget的重绘。而理论上来讲应该只触发form的重绘，甚至只触发对应widget的重绘。</p>
<p>原因在于之前把控制显隐的逻辑全部塞到了渲染控件的widgetData里，而且是computed计算，导致每次逻辑表单相关的值改变，都会新生成所有widget的widgetData。从而触发widget的重渲染。</p>
<p>这个地方提醒了我们在设计组件的时候要关注属性是否变化频繁。有的computed参数只有在初始化的时候会变化，但是影响范围很大。有的参数在后期变化频繁。在设计的时候应该考虑到这些问题，把这两部分的逻辑拆开，避免属性变化频繁触发大面积重新渲染。</p>
<ol start="4">
<li>避免slot所在的父元素更新造成重新渲染</li>
</ol>
<p>在优化的过程中我发现，form里slot的修改也会触发整个form的重新render，这点并非预期。</p>
<p>在功能设计的时候我们需要在form里面插入一个表头，这个表头的报错逻辑和form是通用的，然而内容主要是外部控制的。之前为了实现方便，将title利用slot的方式引入，内容受外部元素控制，报错的类由common-form维护。整体结构下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; parent</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;common-form&gt;</span><br><span class="line">        &lt;div slot&#x3D;&quot;title&quot;&gt;</span><br><span class="line">            &lt;input v-model&#x3D;&quot;title&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;common-form&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际使用的时候，input每做一次修改，parent以及common-form都会重新渲染。导致整个表单在使用的时候卡顿很明显。</p>
<p>在这里parent组件里是通过slot的方式向form组件传递了一个input，实际上操作时我发现每次input的改变不仅会触发parent的重新渲染，还会触发common-form内部的重新渲染。原因在于input的值改变parent进行重新渲染后，common-form的slot组件发生了改变。common-form就被迫进行重新渲染。理论上来讲，common-form的props和内部都没有改变，这部分重新渲染是可以避免的。</p>
<p>针对这个地方vue3.0也做了渲染层面的优化。但是在这里我们只能通过避免slot的使用或者优化结构来进行优化。</p>
<p>最后的处理方法是在parent和common-form中间增加了一个中间层，由于title需要处理一部分公用逻辑，直接把title的逻辑放各个parent组件里不太方便。通过中间层，将title的逻辑放在中间层处理。每次中间层重新渲染，但是由于组件只有一个更新的时间也不会很多。而且各个parent的代码也不需要做很多改动。</p>
<ol start="5">
<li>大招：widget绑定到vuex</li>
</ol>
<p>虽然以上做了很多避免widget重新渲染的优化，但是使用中仍然很卡。实际上根本原因在于form表单太长。每次更新form的时候都会触发form的重新渲染。针对这点我对一些控制属性从数据结构上进行了优化，从原来的数组改为了map。然而改进很小。因为即使每个组件只需要1ms，900多个组件加在一起也高达900ms。而且主要的性能开销也不在于计算，在于dom节点的操作。</p>
<p>针对这个问题，首先我重新对表格的逻辑进行了梳理：</p>
<p>a. 频繁变化的值：表单控件的值<br>b. 中等频繁变化的值：表单控件值控制组件的显示与隐藏<br>c. 不频繁变化的值：表行的显示与隐藏（如果这一行所有控件隐藏，则这一行隐藏）<br>d. 不变化的值：表单的填写信息（如是否需要填写），控件的属性等</p>
<p>根据梳理后的逻辑，我想到的解决渲染太慢办法有几种：</p>
<p>i. 拆分form。我们的表格是按照行和列显示的。每行基本包括6个widget。如果我对form进行拆分，每次渲染的话只需要重新渲染900 / 6个元素。这种方式对代码修改大，而且改进有限。</p>
<p>ii. 将widget的一些控制信息直接存在vuex的store里而不是form的data里。组件也分别从vuex里面取值。这样每次更新vuex就能够只会触发渲染单个widget，避免整个form重绘。</p>
<p>显然第二种方案明显好于第一种方案。于是我对form组件进行了修改。优先针对频繁变化和中等频繁变化的表单进行优化，通过form传递的widgetId从vuex里取得或记录value和display信息，在每次更新的时候也直接对vuex进行操作。这样每次数值变化的时候，只会单独渲染对应的widget。这样form不需要存储子组件model，自然也不会触发重新渲染。卡顿改善非常明显。</p>
<p>之前控制widget展示隐藏的逻辑是在form里遍历计算得到的。改进后将结果也存到了vuex里，而且做了diff，保证根元素不发生变化，避免逻辑表单控制控件显隐时造成form的重新渲染。</p>
<p>为了避免修改太多的控件，我们也针对控件和表格做了一个中间层。这样修改的代码大大地减少了。</p>
<p>至于不频繁变化的值最终决定暂不做优化，不过如果以后需要优化的话也可以用类似的方案解决。form的整体渲染基本只在第一次打开页面时候进行，然而首次渲染这个等待的时间是可以容忍的。</p>
<p>最终，优化后的表单相比较之前速度提升了百倍有余，再也没有用户吐槽太卡了！真棒！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随着个人电脑以及手机的迅猛发展，个人设备的性能越来越优秀，各种性能问题更是被隐藏起来。于此同时，诸如vue和react也大量地诞生，以前的开发组件开发者是基于页面元素的diff做patch，现在的开发者只负责状态管理，由框架来自己做diff做patch。利用框架开发虽然很方便，但是过于依赖框架的功能就会产生各种问题。这个事情提醒我们以后在开发的过程中还是要注重思考，注重设计，从根本上减少不必要的性能开销。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-06-24</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端技术/" title="前端技术">前端技术 </a><a class="tag" href="/tags/vue/" title="vue">vue </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://www.lemonkun.wang/2021/06/24/vue-acceleration/,绝好调超,vue项目性能优化笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/09/13/canvas-inset-shadow/" title="Canvas绘制中的内外阴影还原问题">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/01/19/web-component/" title="Web Component笔记">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>