---
title: 非层级结构树的布局算法
date: 2020-06-04 16:47:36
tags: [算法]
---
最近在做一个项目，涉及到树形结构的拓扑展示。最终选用了g6作为绘图框架（参考文献[4]）。

一般的树形结构布局是采用分层的方式布局，即同一棵树同一层级的元素高度都是相同的。如下图a所示。而下图b所示是一个典型的树形结构布局紧凑树结构，其特点是考虑每个树节点的包围盒，使节点和节点之间的连接更加紧凑，相比于前一种节约了大量的空间。算法时间复杂度为O(n)（多么的神奇）。

![](/images/non-layered-tree/layered.png)

如上图所示：左侧，层级树结构布局，右侧，非层级树结构布局（紧凑布局）。

由于实际布局和紧凑布局有略微的不同，需要自己实现。我便花时间看了下非层级树布局的源代码。以下是我的记录。

# 基本条件
1. 节点和节点应该尽可能紧凑。
2. 父节点在其所有的子节点中间。
3. 不论一个子树放在树的哪一个位置，该子树的布局结构都是一样的。此条件规避了子节点受到父节点影响的情况，即子树的布局只和子节点有关，和父节点无关。

# 算法整体流程
算法的核心思想是对于垂直方向生长的树首先确定垂直方向生长的树的每个节点的y轴位置，通过平移改变节点及其子树的x轴位置使树节点包围块之间避免重叠。

核心算法主要分为以下几个流程：

**1. 准备工作：构造布局计算树**

此步骤是将原始树的节点和结构统一，转化为便于计算树布局的数据结构。
- 首先将水平方向生长的树和垂直方向生长的树统一转化成垂直方向的树计算。将原始树结构转为记录计算中间量的树结构。
- 同时，计算树的包围块大小。每个块的长和宽由树节点的原始长宽加上布局间距（节点和节点之间的横向距离、节点和节点之间的纵向距离）得到。
- 计算每个树节点块y轴的位置，即节点深度，对树进行先序遍历，y轴深度由其所有的祖先节点的y轴偏移得到。在以后的计算中不会再改变。

**2. 第一次遍历（firstWalk）**

- 对树进行后续遍历。
- 如果节点没有子节点，将其x轴偏移设置为0。如果包含子节点, 依次遍历所有的相邻子节点所在的子树。将相邻节点右边节点形成的子树在保证没有冲突的情况下尽可能地靠近左节点形成的子树。（此步骤是算法核心，在下一个步骤中会进行详尽的解释）
- 子节点计算完成之后，计算根节点的位置，为直系子节点左侧边界和右侧边界的中点。

**3. 第二次遍历（secondWalk）**

这一步是为了计算树每个节点的的x轴坐标。在之前的步骤里为了降低时间复杂度只将偏移量记在了父节点上，由于树节点的偏移需要计算节点所有的祖先节点的偏移量和，采用先序遍历进行计算。

**4. 将构造好的树转化为原来的结构。**

**5. 归一化（normalize）**

此步骤是将树整体偏移到视图范围内。

如果树是水平方向生长，将树垂直方向平移使所有值为正数，y轴方向最小值为0（因为x轴向右生长在初始化的步骤里就已经确定了位置，在计算的时候没有改动）

如果树是垂直方向生长，则将树水平方向平移最小x值个单位，使所有的x为正数。

# 算法核心

**1. 保证同一层级节点不重叠。**

![](/images/non-layered-tree/child-subtree.png)


本步骤是算法的核心。对树进行后序遍历，从子节点开始向上对子树进行向右平移。

对同一根节点下面的所有直系子节点的间隔进行遍历，保证直系子节点所在的子树两两互相不重叠：

如上图所示，对于3号节点和7号节点，需要判断3号节点所在的子树（3,4,6,5）以及7号节点所在的子树（7,8,9）互相不重叠。将问题简化为同一水平线上两棵子树对应的轮廓不重叠，通过比较同一水平的轮廓，得到contour pairs，3-7，7-6，6-8，8-4 ，依次计算每个contour pair保证两两不重叠，如重叠，则将右侧节点对应的子树整体偏移重叠部分的宽度即可。

**2. 轮廓的计算**

![](/images/non-layered-tree/contour.png)

为了判断子树是否重叠，我们需要对每棵树的子节点进行遍历计算树的轮廓。如果直接遍历，时间复杂度为O(n^2)。Reingold and Tilford 提出了一个Thread算法对这个地方做了优化。在计算是否重叠的过程中顺带计算了轮廓。

首先考虑层级树的情况，如图所示，实线表示节点之间的父子关系，虚线表示轮廓。

对于包含字节点的树，我们可知其下一层的左轮廓为其子节点第一个节点，右轮廓为其子节点最后一个节点。

对于不包括子节点的树，其左轮廓为其下一层节点的最左侧节点，其右轮廓为其下一层节点的最右侧节点。

我们需要一个链表记录每一层的轮廓。

在比较节点4和节点5分别构成的子树时，我们可知节点5所在的子树比节点4要更深（右子树深于左子树），我们记录节点5下一层的左轮廓为ri，右轮廓为ro，此时我们将节点4设置指针指向节点5下一层的树形结构的左轮廓。

同理，针对节点2和节点3分别构成的子树，节点2构成的树深度要比节点3的要高，（左子树深于右子树），我们将节点3设置指针指向节点2下一层的右轮廓，即节点5。

这样在顶层父节点需要获得轮廓计算是否重叠的时候我们就能方便地获得轮廓的链表。而且避免了对每棵树的子节点进行遍历。


![](/images/non-layered-tree/non-layered-contour.png)

同理，非层级树的计算方法和本方法基本一致，只不过针对的不是下一层的右轮廓，是更深一层节点的右轮廓（可能并非一层）。只需要多进行一次轮廓的最低点比较即可。

当计算节点2左侧的兄弟节点子树与3节点所对应的子树是否重叠的时候，构造了一个左兄弟的查找链表，来记录从最左边到最右边递减的bottom，即左侧兄弟节点子树的外轮廓。如果能保证与外轮廓不重叠，即可保证和左侧兄弟节点构成的子树集合不重叠。

**3. 布局优化**

![](/images/non-layered-tree/seperate.png)

优化布局，如上图所示，将节点5按照节点6的位置向右偏移后，节点1-节点4中间的距离很小，节点4-节点5之间的距离很大。此时出于布局美观的考虑将偏移距离d平均分布到在节点1-节点5上。即节点2偏移距离为1/4d，节点3偏移距离2/4d，节点4偏移距离3/4d。

每次向右移动子树，需要判断是否需要向右平移左侧子兄弟构成的子树。如果向右移动兄弟子树会和当前子树冲突，则不可移动。以下是这样考虑这个问题的：

- 移动造成重叠一定是左侧兄弟构成的子树集合和当前子树重叠引起的。左侧兄弟构成的子树集合内部因为距离变大，不会因为向右平移造成重叠。
- 考虑兄弟子树集合内部子树轮廓，如果最右侧子树深度大于倒数第二棵子树，即集合的右轮廓完全由倒数第一个子树构成，那么当最右侧子树向右平移的时候，一定会因为和新增的当前子树距离变小发生重叠（因为是按照当前最小距离计算的）。
- 如果集合的右轮廓由不同的子树构成，那么如果当前子树（如上图5节点）需要针对该子树（如上图1节点对应子树）的轮廓向右平移，则1 - 5 节点之间可以平均分配距离d，且不会造成重叠。

此步骤同样可以在firstWalk里实现，不需要另外对树进行额外的比那里。只需要计算的时候保留同层兄弟节点轮廓链表，记录左侧兄弟所有以子树（已经布局完成的子树）构成的轮廓最低点以及兄弟节点的索引。

在比较同一深度是否需要向右平移当前子树时，如果需要平移，再将平移距离平均分配到其他兄弟节点，即可实现。

**4. 整体流程如下：**

![](/images/non-layered-tree/step1.png)

原始树结构

![](/images/non-layered-tree/step2.png)

平移第一次树结构

![](/images/non-layered-tree/step1.png)

平均分配距离后的树结构

![](/images/non-layered-tree/step2.png)

平移第二次树结构

![](/images/non-layered-tree/step1.png)

平均分配距离后的树结构

# 降低算法时间复杂度核心思想

1. 只记录节点偏移量，不记录偏移总量。
每次移动整棵子树的位置的时候，为了降低时间复杂度没有通过遍历树的每一个节点计算历次偏总和实现。

- 因为是从子节点开始遍历，再遍历父节点，每次遍历同层子树将偏移量记录在子树的根节点上。
- 在计算优化布局平均分配过长的距离的时候，同样通过记录起始点、终止点的变化率和变化量来判断。如上，记录节点1偏移量为0，变化率为 1/4d，记录点5变化率变为0。这样避免了对中间节点设置偏移量的遍历。

> 如平均分配从n到m子节点之间的距离，记录n+1号子节点的shift（变化率）为 d / (m - n)，记录节点m的shift为 - d / (m - n)，在计算偏移量的时候需要对从左向右的节点的变化率求累和，为了防止m以后的节点受到影响，记录m点的change为 - d + d / (m - n)。在计算每个节点的偏移量时将累和的结果再加上单点的偏移量 change即可得到节点及其子树的偏移。与步骤a中计算得到的偏移就是节点及其子树的总偏移。

2. 通过链表记录树的轮廓。

以上已经对这个问题进行完整的叙述，不再讨论。

整体来讲，算法的中心思想只看代码理解起来还是比较困难，建议参考相关论文，从分层树结构布局开始再（参考文献 [3]）引申到无分层树结构布局（参考文献 [1]）。
本算法的详细实现请参考参考文献2。本文就不贴伪代码了。

# 最终的小应用

产品要求实现的功能是如图所示的拓扑型结构图，节点主要分为主节点和从节点两种。从节点没有子节点，位置需要摆放在主节点的右侧，如下图所示。

![](/images/non-layered-tree/pm.png)

布局方面其实不使用非层级树布局这么麻烦的算法也是没有问题的，但是G6没有提供布局方法，我只能在大概理解算法思路之后直接在已有布局上修改代码的方法完成。实际上我在完成这个功能的时候也没有对非层级树布局算法理解这么深入。

思路也很简单粗暴：
1. 在构造布局树的时候，区分主节点和从节点，将从节点从树形结构中删掉，额外保留在主节点上。
2. 修改主节点的布局宽度计算，已有主节点的宽度计算时只有节点宽度加上边距，修改为额外增加从节点宽度。
3. 在还原子树的时候，根据主节点的位置计算从节点的位置，补充到树形结构上。

以上三步完成之后，块的布局就完成了。然而最终的布局除了点还需要考虑边的形状，边上文字的排列等等。比如当时一个花了一段时间解决的问题就是这样的：G6默认提供的贝塞尔曲线分为水平方向(cubic-horizontal)和垂直方向(cubic-vertical)两种，实际布局带有从节点的需要水平方向贝塞尔曲线，只有主节点的布局需要垂直方向贝塞尔曲线。需要自己根据线的起点和终点判断（且由于树形结构不包含线的设置，此部分最终是在线的模型函数里判断的）。
以上。


参考文献：
[1] http://emr.cs.iit.edu/~reingold/tidier-drawings.pdf

[2] non-layered-tidy.js https://github.com/antvis/hierarchy/blob/master/src/layout/non-layered-tidy.js

[3] Drawing Presentable Trees
 https://llimllib.github.io/pymag-trees/
 
[4] G6 Documents https://g6.antv.vision/zh/docs/manual/introduction

