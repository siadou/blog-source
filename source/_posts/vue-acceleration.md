---
title: vue项目性能优化笔记
date: 2021-06-24 10:51:44
tags: [前端技术, vue]
---

# 项目背景

最近在做一个基于vue的项目，用户可以通过在表格里设置各种控件，让使用者在不同的流程提交不同的字段。同事在使用时配置了一个900多个组件的table，用的时候感觉表很卡顿，每次输入字符都会卡顿好久才会有响应。于是我奉命对表单进行优化。

我首先研究了一下卡顿的原因：最开始在设计的时候把所有的widget放在了一个form里面，也把每个widget绑定的值绑在了form的data里。每个widget的值修改的时候，form的data发生改变，触发form重新渲染。由于这个表单太大，本身渲染就会花费很多时间（以下为省略结构，实际上还要复杂很多）而且实际在用的时候不仅form会重新渲染，子元素widget也会重新渲染，虽然不会触发卡顿问题，但是仍然对性能造成消耗。发现这个问题的时候我忽然想到，其实这种问题在以前的jquery时代是不存在的，每次修改表单的字符最多只是对当前widget的修改。怎么到了vue反而越来越糟糕，每次修改值都会触发整个表单和所有widget的重新渲染。于是我构思了优化的方案。

```
<template>
<form>
    <widget v-model="model.k1" @change="changeHandler(widget.id)" :key="widget.id"/>
    .....
</form>
</template>
<script>
export defualt {
    data() {
        return {
            model: {}
        }
    }
}
</script>
```

# 参考

相比于react，vue 是响应式框架，自带优化。组件的渲染方法和渲染需要的参数绑定。即使父组件更新了，子组件如果接受到的prop等参数没有更新的话也不会触发子组件的重绘。这点与react不同，react需要构造pureComponent或者手写shouldComponentUpdate才会对渲染进行优化。
除此以外，我们的项目由于需要支持IE11暂时还没升级到vue3.0。但是我们了解到vue3.0在一些渲染方面做了优化。

# 优化

于是我从以下几点对form进行了优化：

1. widget的结构优化

这是第一次优化，也是一次应急优化。之前widget不维护内部变量，每次input都会更新model。我把一部分的widget的内部变量维护逻辑放在了组件里，避免频繁地更新外部变量。

除此以外，升级了element-ui之后，组件input/change的触发逻辑有了区分。input widget的change只会在blur时触发。于是我把复杂的涉及逻辑表单的逻辑放在了change里，简单的修改值的操作放在了input里。避免了不必要的计算。


2. 避免绑定事件造成的widget重新渲染

理论上来讲，单个widget的值更新后，form重新渲染应该不会触发其他widget的重新渲染。可实际上所有的widget都会重新渲染一遍。

原因是vue之前的版本不会保存事件handler.bind后的结果，每一次组件都会绑定新的listener。导致每次form重新渲染都会生成新的handler,从而触发子组件的渲染。

针对这个问题，我对lister设置了缓存。每次重渲染都会针对不同的widget读取上一次的值，解决了这个问题。

vue3.0也针对这里做了优化。这样在使用template的时候就不需要手动去设置缓存了（但是我们这里用的是jsx其实即使升级也需要手动优化...）。

3. 拆分变与不变

我们的表单在设计的时候包含了逻辑表单的功能，在用户填写表单的时候能够通过单个选项的值控制部分widget的显示与隐藏。实际在用的时候，我发现即使优化了widget的渲染，在修改逻辑表单的值时一些情况下仍然会触发所有widget的重绘。而理论上来讲应该只触发form的重绘，甚至只触发对应widget的重绘。

原因在于之前把控制显隐的逻辑全部塞到了渲染控件的widgetData里，而且是computed计算，导致每次逻辑表单相关的值改变，都会新生成所有widget的widgetData。从而触发widget的重渲染。

这个地方提醒了我们在设计组件的时候要关注属性是否变化频繁。有的computed参数只有在初始化的时候会变化，但是影响范围很大。有的参数在后期变化频繁。在设计的时候应该考虑到这些问题，把这两部分的逻辑拆开，避免属性变化频繁触发大面积重新渲染。



4. 避免slot所在的父元素更新造成重新渲染

在优化的过程中我发现，form里slot的修改也会触发整个form的重新render，这点并非预期。

在功能设计的时候我们需要在form里面插入一个表头，这个表头的报错逻辑和form是通用的，然而内容主要是外部控制的。之前为了实现方便，将title利用slot的方式引入，内容受外部元素控制，报错的类由common-form维护。整体结构下：

```
// parent

<div>
    <common-form>
        <div slot="title">
            <input v-model="title" />
        </div>
    </common-form>
</div>

```

实际使用的时候，input每做一次修改，parent以及common-form都会重新渲染。导致整个表单在使用的时候卡顿很明显。

在这里parent组件里是通过slot的方式向form组件传递了一个input，实际上操作时我发现每次input的改变不仅会触发parent的重新渲染，还会触发common-form内部的重新渲染。原因在于input的值改变parent进行重新渲染后，common-form的slot组件发生了改变。common-form就被迫进行重新渲染。理论上来讲，common-form的props和内部都没有改变，这部分重新渲染是可以避免的。

针对这个地方vue3.0也做了渲染层面的优化。但是在这里我们只能通过避免slot的使用或者优化结构来进行优化。

最后的处理方法是在parent和common-form中间增加了一个中间层，由于title需要处理一部分公用逻辑，直接把title的逻辑放各个parent组件里不太方便。通过中间层，将title的逻辑放在中间层处理。每次中间层重新渲染，但是由于组件只有一个更新的时间也不会很多。而且各个parent的代码也不需要做很多改动。

5. 大招：widget绑定到vuex

虽然以上做了很多避免widget重新渲染的优化，但是使用中仍然很卡。实际上根本原因在于form表单太长。每次更新form的时候都会触发form的重新渲染。针对这点我对一些控制属性从数据结构上进行了优化，从原来的数组改为了map。然而改进很小。因为即使每个组件只需要1ms，900多个组件加在一起也高达900ms。而且主要的性能开销也不在于计算，在于dom节点的操作。

针对这个问题，首先我重新对表格的逻辑进行了梳理：

a. 频繁变化的值：表单控件的值
b. 中等频繁变化的值：表单控件值控制组件的显示与隐藏
c. 不频繁变化的值：表行的显示与隐藏（如果这一行所有控件隐藏，则这一行隐藏）
d. 不变化的值：表单的填写信息（如是否需要填写），控件的属性等

根据梳理后的逻辑，我想到的解决渲染太慢办法有几种：

i. 拆分form。我们的表格是按照行和列显示的。每行基本包括6个widget。如果我对form进行拆分，每次渲染的话只需要重新渲染900 / 6个元素。这种方式对代码修改大，而且改进有限。

ii. 将widget的一些控制信息直接存在vuex的store里而不是form的data里。组件也分别从vuex里面取值。这样每次更新vuex就能够只会触发渲染单个widget，避免整个form重绘。

显然第二种方案明显好于第一种方案。于是我对form组件进行了修改。优先针对频繁变化和中等频繁变化的表单进行优化，通过form传递的widgetId从vuex里取得或记录value和display信息，在每次更新的时候也直接对vuex进行操作。这样每次数值变化的时候，只会单独渲染对应的widget。这样form不需要存储子组件model，自然也不会触发重新渲染。卡顿改善非常明显。

之前控制widget展示隐藏的逻辑是在form里遍历计算得到的。改进后将结果也存到了vuex里，而且做了diff，保证根元素不发生变化，避免逻辑表单控制控件显隐时造成form的重新渲染。

为了避免修改太多的控件，我们也针对控件和表格做了一个中间层。这样修改的代码大大地减少了。

至于不频繁变化的值最终决定暂不做优化，不过如果以后需要优化的话也可以用类似的方案解决。form的整体渲染基本只在第一次打开页面时候进行，然而首次渲染这个等待的时间是可以容忍的。

最终，优化后的表单相比较之前速度提升了百倍有余，再也没有用户吐槽太卡了！真棒！

# 总结

随着个人电脑以及手机的迅猛发展，个人设备的性能越来越优秀，各种性能问题更是被隐藏起来。于此同时，诸如vue和react也大量地诞生，以前的开发组件开发者是基于页面元素的diff做patch，现在的开发者只负责状态管理，由框架来自己做diff做patch。利用框架开发虽然很方便，但是过于依赖框架的功能就会产生各种问题。这个事情提醒我们以后在开发的过程中还是要注重思考，注重设计，从根本上减少不必要的性能开销。
