<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>MutationObserver及其在富文本编辑器里的应用和Vue里的应用 · 绝好调超</title><meta name="description" content="MutationObserver接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。本文将介绍它的用法和在富文本编辑器draft-js里的应用和在Vue的nextTick里的应用。
Mutation"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">绝好调超</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>MutationObserver及其在富文本编辑器里的应用和Vue里的应用</a></h3></div><div class="post-content"><p><code>MutationObserver</code>接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。<br>本文将介绍它的用法和在富文本编辑器draft-js里的应用和在Vue的nextTick里的应用。</p>
<h1 id="MutationObserver-API"><a href="#MutationObserver-API" class="headerlink" title="MutationObserver API"></a>MutationObserver API</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>MutationObserver()</code></p>
<p>创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><code>disconnect()</code></p>
<p>阻止 MutationObserver 实例继续接收的通知，直到再次调用其observe()方法，该观察者对象包含的回调函数都不会再被调用。</p>
<p><code>observe(target[, options])</code></p>
<p>配置MutationObserver在DOM更改匹配给定选项时，通过其回调函数开始接收通知。</p>
<p><code>takeRecords()</code></p>
<p>从MutationObserver的通知队列中删除所有待处理的通知，并将它们返回到MutationRecord对象的新Array中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const observer &#x3D; new MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以上述配置开始观察目标节点</span><br><span class="line">observer.observe(targetNode, config);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 之后，可停止观察</span><br><span class="line">observer.disconnect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="在富文本编辑器框-draft-js里的应用"><a href="#在富文本编辑器框-draft-js里的应用" class="headerlink" title="在富文本编辑器框 draft-js里的应用"></a>在富文本编辑器框 draft-js里的应用</h1><p>draft-js是facebook开发第一款基于react的开源富文本编辑器框架。为了记录用户对内容的修改，draft-js使用 <code>MutationObserver</code>对编辑器节点进行观察，记录用户对内容的改变操作。当onCompositionStart的时候开始观察，当<code>onCompositionEnd</code>事件触发(防止事件未处理完，源码此处做了延时)或者键盘操作的时候结束观察。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">const DOM_OBSERVER_OPTIONS &#x3D; &#123;</span><br><span class="line">  subtree: true,</span><br><span class="line">  characterData: true,</span><br><span class="line">  childList: true,</span><br><span class="line">  characterDataOldValue: false,</span><br><span class="line">  attributes: false,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified</span><br><span class="line">&#x2F;&#x2F; 由于IE11的MutationObserver存在严重的问题，采用DOMCharacterDataModified监控变化</span><br><span class="line">const USE_CHAR_DATA &#x3D; UserAgent.isBrowser(&#39;IE &lt;&#x3D; 11&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DOMObserver &#123;</span><br><span class="line">  observer: ?MutationObserver;</span><br><span class="line">  container: HTMLElement;</span><br><span class="line">  mutations: Map&lt;string, string&gt;;</span><br><span class="line">  onCharData: ?(&#123;</span><br><span class="line">    target: EventTarget,</span><br><span class="line">    type: string,</span><br><span class="line">    ...</span><br><span class="line">  &#125;) &#x3D;&gt; void;</span><br><span class="line"></span><br><span class="line">  constructor(container: HTMLElement) &#123;</span><br><span class="line">    this.container &#x3D; container;</span><br><span class="line">    this.mutations &#x3D; Map();</span><br><span class="line">    const containerWindow &#x3D; getWindowForNode(container);</span><br><span class="line">    if (containerWindow.MutationObserver &amp;&amp; !USE_CHAR_DATA) &#123;</span><br><span class="line">      this.observer &#x3D; new containerWindow.MutationObserver(mutations &#x3D;&gt;</span><br><span class="line">        this.registerMutations(mutations),</span><br><span class="line">      );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;此处采用DOMCharacterDataModified监控变化省略</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start(): void &#123;</span><br><span class="line">    if (this.observer) &#123;</span><br><span class="line">      this.observer.observe(this.container, DOM_OBSERVER_OPTIONS);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;此处采用DOMCharacterDataModified监控变化省略</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stopAndFlushMutations(): Map&lt;string, string&gt; &#123;</span><br><span class="line">    const &#123;observer&#125; &#x3D; this;</span><br><span class="line">    if (observer) &#123;</span><br><span class="line">      this.registerMutations(observer.takeRecords());</span><br><span class="line">      observer.disconnect();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;此处采用DOMCharacterDataModified监控变化省略</span><br><span class="line">    &#125;</span><br><span class="line">    const mutations &#x3D; this.mutations;</span><br><span class="line">    this.mutations &#x3D; Map();</span><br><span class="line">    return mutations;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  registerMutations(mutations: Array&lt;MutationRecord&gt;): void &#123;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; mutations.length; i++) &#123;</span><br><span class="line">      this.registerMutation(mutations[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  registerMutation(mutation: MutationRecordT): void &#123;</span><br><span class="line">    const textContent &#x3D; this.getMutationTextContent(mutation);</span><br><span class="line">    if (textContent !&#x3D; null) &#123;</span><br><span class="line">      const offsetKey &#x3D; nullthrows(findAncestorOffsetKey(mutation.target));</span><br><span class="line">      this.mutations &#x3D; this.mutations.set(offsetKey, textContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 对提交内容的处理</span><br><span class="line">  getMutationTextContent(mutation: MutationRecordT): ?string &#123;</span><br><span class="line">    const &#123;type, target, removedNodes&#125; &#x3D; mutation;</span><br><span class="line">    if (type &#x3D;&#x3D;&#x3D; &#39;characterData&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; When &#96;textContent&#96; is &#39;&#39;, there is a race condition that makes</span><br><span class="line">      &#x2F;&#x2F; getting the offsetKey from the target not possible.</span><br><span class="line">      &#x2F;&#x2F; These events are also followed by a &#96;childList&#96;, which is the one</span><br><span class="line">      &#x2F;&#x2F; we are able to retrieve the offsetKey and apply the &#39;&#39; text.</span><br><span class="line">      if (target.textContent !&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">        return target.textContent;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (type &#x3D;&#x3D;&#x3D; &#39;childList&#39;) &#123;</span><br><span class="line">      if (removedNodes &amp;&amp; removedNodes.length) &#123;</span><br><span class="line">        &#x2F;&#x2F; &#96;characterData&#96; events won&#39;t happen or are ignored when</span><br><span class="line">        &#x2F;&#x2F; removing the last character of a leaf node, what happens</span><br><span class="line">        &#x2F;&#x2F; instead is a &#96;childList&#96; event with a &#96;removedNodes&#96; array.</span><br><span class="line">        &#x2F;&#x2F; For this case the textContent should be &#39;&#39; and</span><br><span class="line">        &#x2F;&#x2F; &#96;DraftModifier.replaceText&#96; will make sure the content is</span><br><span class="line">        &#x2F;&#x2F; updated properly.</span><br><span class="line">        return &#39;&#39;;</span><br><span class="line">      &#125; else if (target.textContent !&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; Typing Chinese in an empty block in MS Edge results in a</span><br><span class="line">        &#x2F;&#x2F; &#96;childList&#96; event with non-empty textContent.</span><br><span class="line">        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;draft-js&#x2F;issues&#x2F;2082</span><br><span class="line">        return target.textContent;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="在Vue的nextTick中的应用"><a href="#在Vue的nextTick中的应用" class="headerlink" title="在Vue的nextTick中的应用"></a>在Vue的nextTick中的应用</h1><p><code>nextTick</code>函数在Vue框架中会在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，可以获取到更新后的 DOM。</p>
<p>在Vue中的nextTick函数中，MutationObserver用法和普通的用法有着很大的差别的自身功能被淡化仅作为一个异步的API被调用，。MutationObserver的作用是作为异步函数将本周期应该执行的事件推迟到下个周期里。<br>代码详见<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/d7d8ff06b70cf1a2345e3839c503fdb08d75ba49/src/core/util/next-tick.js#L1">这里</a></p>
<p>核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">let timerFunc</span><br><span class="line">if (typeof Promise !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; isNative(Promise)) &#123;</span><br><span class="line">  const p &#x3D; Promise.resolve()</span><br><span class="line">  timerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    if (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask &#x3D; true</span><br><span class="line">&#125; else if (!isIE &amp;&amp; typeof MutationObserver !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  &#x2F;&#x2F; PhantomJS and iOS 7.x</span><br><span class="line">  MutationObserver.toString() &#x3D;&#x3D;&#x3D; &#39;[object MutationObserverConstructor]&#39;</span><br><span class="line">)) &#123;</span><br><span class="line">  &#x2F;&#x2F; Use MutationObserver where native Promise is not available,</span><br><span class="line">  &#x2F;&#x2F; e.g. PhantomJS, iOS7, Android 4.4</span><br><span class="line">  &#x2F;&#x2F; (#6466 MutationObserver is unreliable in IE11)</span><br><span class="line">  let counter &#x3D; 1</span><br><span class="line">  const observer &#x3D; new MutationObserver(flushCallbacks)</span><br><span class="line">  const textNode &#x3D; document.createTextNode(String(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: true</span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    counter &#x3D; (counter + 1) % 2</span><br><span class="line">    textNode.data &#x3D; String(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask &#x3D; true</span><br><span class="line">&#125; else if (typeof setImmediate !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  &#x2F;&#x2F; Fallback to setImmediate.</span><br><span class="line">  &#x2F;&#x2F; Technically it leverages the (macro) task queue,</span><br><span class="line">  &#x2F;&#x2F; but it is still a better choice than setTimeout.</span><br><span class="line">  timerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; Fallback to setTimeout.</span><br><span class="line">  timerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由以上代码可知，在nextTick里面一共完成了以下任务：</p>
<ol>
<li>将目标执行函数推入异步队列中</li>
<li>执行timerFunc（使异步队列里面的所有内容在下一个周期里执行）</li>
<li>返回一个Promise对象。当最后一个没有callback函数执行的空的nextTick执行的时候，Promise会被resolve。</li>
<li>如果同一个同步周期里有多次NextTick的调用，第二次调用只会将目标函数推到队列中。（防止队列里的内容多次执行）</li>
</ol>
<p>timerFunc是将待执行事件推迟到下一个事件循环里面执行的函数。<br>源代码里面按照不同优先级一共用了4种方法：</p>
<p>实际上MutationObserver 有更高的支持度。然而在iOS&gt; = 9.3.3中的UIWebView中存在严重的bug。在触发几次之后会失效。所以还是优先采用Promise的方法</p>
<p>由于浏览器对macro task和micro task的处理的方式有着微妙的差别，micro task触发新的micro task后会直接加在原有的队尾执行再进行浏览器的UI线程渲染，而macro task则会先触发渲染再执行新的micro task，如果此时有数据修改又会触发重复渲染，导致采用macro task会存在一些抖动问题，性能相比也差一些。（详见参考文献6）。timerFunc优先采用micro task(微任务)，fallback采用macro task (宏任务)，最终以以下优先级实现：</p>
<ol>
<li>优先采用Promise.resolve<br>创建一个Promise对象，在timerFunc里通过resolve来在下一个eventloop里处理队列里面的任务。</li>
<li>MutationObserver<br>创建一个文本节点，并创建一个MutationObserver监听文本节点里面的内容改变。在timerFunc里面改变文本节点的内容。由于在IE和iOS&gt; = 9.3.3中的UIWebView中存在bug，作为Promise的备选项。</li>
<li>setImmediate<br>相比于setTimeout可以直接运行，而setTimeout需要js引擎和系统的时钟同步，同步的频率在4ms，所以优先选择前者。</li>
<li>setTimeout</li>
</ol>
<h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a></li>
<li><a target="_blank" rel="noopener" href="https://javascript.ruanyifeng.com/dom/mutationobserver.html">Mutation Observer API</a></li>
<li><a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014812771?utm_source=channel-hottest">Tasks, microtasks, queues and schedules（译）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sevenCon/blog-github/issues/14">vue.js 中nextTick 和setTimeout有什么区别</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/draft-js/blob/master/src/component/handlers/composition/DOMObserver.js#L120">draft-js DOMObserver</a></li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-10</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端技术/" title="前端技术">前端技术 </a><a class="tag" href="/tags/浏览器/" title="浏览器">浏览器 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://www.lemonkun.wang/2020/10/10/mutation-observer/,绝好调超,MutationObserver及其在富文本编辑器里的应用和Vue里的应用,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/01/19/web-component/" title="Web Component笔记">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/10/10/custom-stylesheet/" title="自定义主题颜色实现方案">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>